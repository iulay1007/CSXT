/*
2路插入排序
2路插入是在折半插入的基础上进行改进。
折半插入在原先直接插入的基础上改进，通过折半查找，以较少的比较次数就找到了要插入的位置，但是在插入的过程中仍然没有减少移动次数，所以2路插入在此基础上改进，减少了移动次数，但是仍然并没有避免移动记录（如果要避免的话还是得改变存储结构）
那么如何减少的移动次数？？？
常规的一个数组{2, 7, 8,10,15 ,29,30, 40,50,66,70,80}，如果插入9，那么按照常规的折半查找后，需要移动记录9次，这是因为我们只能够在一个方向上插入。
因此我们设定一个辅助数组A，大小是原来数组相同的大小，将A[0]设为第一个原数组第一个数，通过设置first和final指向整个有序序列的最小值和最大值，即为序列的尾部和头部，并且将其设置位一个循环数组，这样就可以进行双端插入。此时原数组只需往左边移动3次。

之所以能减少移动次数的原因在于可以往2个方向移动记录，故称为2路插入。
A[0]的前面是个有序序列，后面也是有序序列，整个也是有序序列

具体操作思路：
1.将原数组第一个元素赋值给A[0],作为标志元素
2.按顺序依次插入剩下的原数组的元素

将带插入元素与第一个进行比较，偌大于A[0],则插入A[0]前面的有序序列，否则插入后面的有序序列
对前面的有序序列或后面的有序序列进行折半查找
查找到插入位置后进行记录的移动，分别往first方向前移和往final方向移动
插入记录
3.将排序好的A数组的数据从first到final，按次序赋值回原数组。
*/
void TwoPathInsertSort(SqList *L)
 { /* 2_路插入排序 */
   int i,j,first,final;
   int *d;
   d=(int*)malloc((*L).length*sizeof(int)); /* 生成L.length个记录的临时空间 */
   d[0]=(*L).r[1]; /* 设L的第1个记录为d中排好序的记录(在位置[0]) */
   first=final=0; /* first、final分别指示d中排好序的记录的第1个和最后1个记录的位置 */
   for(i=2;i<=(*L).length;++i)
   { /* 依次将L的第2个～最后1个记录插入d中 */
     if((*L).r[i].key<d[first].key)
     { /* 待插记录小于d中最小值，插到d[first]之前(不需移动d数组的元素) */
       first=(first-1+(*L).length)%(*L).length; 
       d[first]=(*L).r[i];
     }
     else if((*L).r[i].key>d[final].key)
     { /* 待插记录大于d中最大值，插到d[final]之后(不需移动d数组的元素) */
       final=final+1;
       d[final]=(*L).r[i];
     }
     else
     { /* 待插记录大于d中最小值，小于d中最大值，插到d的中间(需要移动d数组的元素) */
       j=final++; /* 移动d的尾部元素以便按序插入记录 */
       while((*L).r[i].key<d[j].key)
       {
         d[(j+1)%(*L).length]=d[j];
         j=(j-1+(*L).length)%(*L).length;
       }
       d[j+1]=(*L).r[i];
     }
   }
   for(i=1;i<=(*L).length;i++) /* 把d赋给L.r */
     (*L).r[i]=d[(i+first-1)%(*L).length]; 
 }

